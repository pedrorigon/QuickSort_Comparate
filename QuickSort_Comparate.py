# -*- coding: utf-8 -*-
"""Cópia de labCPD-02-Python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mAgkcEBb5bgDNCmIrkC9Isr8wtoioc3f

# Disciplina de Classificação e Pesquisa de Dados

# Laboratório #2

### Implementação (em Python) dos principais algoritmos de Classificação por Trocas.

A seguir você encontra os algoritmos bublesort e quicksort-padrão, com uma versão tradicional do algoritmo de partição. 

Analise os algoritmos e os resultados apresentados na avaliação de desempenho.
"""

# Bibliotecas necessárias ao script:
import numpy as np  # importa a biblioteca numpy (que trabalha com arrays numéricos)
import time         # importa a biblioteca utilizada para contar o tempo
import pandas as pd # biblioteca para trabalhar com data frames
import math
import statistics
import random


################################################
# Algoritmos de ordenação
################################################

# Bubblesort
def bubble_sort(array): 
    trocas = comparacoes = pos_troca = 0
    qtd_elementos = len(array)-1
    troca = True
    
    while troca:
        troca = False
        for i in range(0, qtd_elementos):
            comparacoes = comparacoes + 1
            if array[i] > array[i+1]:
                tmp = array[i]
                array[i] = array[i+1]
                array[i+1] = tmp
                troca = True  
                pos_troca = i
                trocas = trocas + 1
        qtd_elementos = pos_troca
                
    return {'trocas':trocas, 'comparacoes':comparacoes}

# Quicksort e funções auxiliares
def quick_sort(array):
    log_operacoes = {'trocas':0, 'comparacoes':0}
    quicksort(array, 0, len(array)-1, log_operacoes)
    return log_operacoes

def quicksort(array, inicio, fim, log_operacoes):
    if fim > inicio:
        pivo = particiona(array, inicio, fim, log_operacoes)
        quicksort(array, inicio, pivo-1, log_operacoes)
        quicksort(array, pivo+1, fim, log_operacoes)
    return log_operacoes

def particiona(array, esquerda, direita, log_operacoes):
    pivo = esquerda
    i = pivo + 1 
    j = direita
    
    while i<j:
        while (array[j] >= array[pivo]) and (j > esquerda): # procura menor à direita
            j = j - 1
            log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1 
        
        while (array[i] < array[pivo]) and (i < direita): # procura maior à esquerda
            log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1 
            i = i + 1
            
        if (i<j) and (array[i] > array[j]):
            log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1 
            log_operacoes['trocas'] = log_operacoes['trocas'] + 1 
            tmp = array[i]
            array[i] = array[j]
            array[j] = tmp

    if array[j] < array[pivo]:
        log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1 
        log_operacoes['trocas'] = log_operacoes['trocas'] + 1 
        tmp = array[j]
        array[j] = array[pivo]
        array[pivo] = tmp
    
    return j;

################################################
# Implementação dos seus algoritmos:
   
def comb_sort(array):
    log_operacoes = {'trocas':0, 'comparacoes':0}
    distancia = len(array)
    Flag_Fluxo = True
    Trade_var = 0
    while distancia != 1 or Flag_Fluxo:
      log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1 
      Flag_Fluxo = False
      distancia = int(distancia / 1.3)
      if distancia < 1:
        distancia = 1
      for cont in range(0,len(array)-distancia):
        if array[cont] > array[cont+distancia]:
          log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1 
          array[cont], array[cont+distancia] = array[cont+distancia], array[cont]
          log_operacoes['trocas'] = log_operacoes['trocas'] + 1 
          Flag_Fluxo = True

    return log_operacoes 
    
def shake_sort(array):
    log_operacoes = {'trocas':0, 'comparacoes':0}
    for cont in range(len(array) //2):
      Flag_Fluxo = False
      for cont2 in range(1+cont, len(array)-cont):
        if array[cont2] < array[cont2-1]:
          log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1 
          array[cont2], array[cont2-1] = array[cont2-1], array[cont2]
          log_operacoes['trocas'] = log_operacoes['trocas'] + 1 
          Flag_Fluxo = True
      if Flag_Fluxo == False:
        break
      Flag_Fluxo = False
      for cont2 in range(len(array)-cont-1, cont, -1):
        if array[cont2] < array[cont2-1]:
          log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1 
          array[cont2],array[cont2-1] = array[cont2-1], array[cont2]
          log_operacoes['trocas'] = log_operacoes['trocas'] + 1 
          Flag_Fluxo = True
      if Flag_Fluxo == False:
        break    
    return log_operacoes 
   
def quick_sort2(array):
    log_operacoes = {'trocas':0, 'comparacoes':0}
    ElementosIguais = True
    for i in range(0, len(array)-1):
      log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1 
      if(array[0] != array[i+1]):
        ElementosIguais = False
    if(ElementosIguais == True):
        return log_operacoes

    quicksort2(array, 0, len(array)-1, log_operacoes)
    return log_operacoes

def quicksort2(array, inicio, fim, log_operacoes):

    if fim > inicio:
        pivo = particiona2(array, inicio, fim, log_operacoes)
        quicksort2(array, inicio, pivo-1, log_operacoes)
        quicksort2(array, pivo+1, fim, log_operacoes)
    return log_operacoes


def particiona2(array, esquerda, direita, log_operacoes):

    from random import randrange
    x = randrange(esquerda, direita)
    array[esquerda], array[x] = array[x], array[esquerda]

    pivo = esquerda
    i = pivo + 1 
    j = direita

    while i<j:
        while (array[j] >= array[pivo]) and (j > esquerda): # procura menor à direita
            j = j - 1
            log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1 
        
        while (array[i] < array[pivo]) and (i < direita): # procura maior à esquerda
            log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1 
            i = i + 1
            
        if (i<j) and (array[i] > array[j]):
            log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1 
            log_operacoes['trocas'] = log_operacoes['trocas'] + 1 
            tmp = array[i]
            array[i] = array[j]
            array[j] = tmp

    if array[j] < array[pivo]:
        log_operacoes['comparacoes'] = log_operacoes['comparacoes'] + 1 
        log_operacoes['trocas'] = log_operacoes['trocas'] + 1 
        tmp = array[j]
        array[j] = array[pivo]
        array[pivo] = tmp
    
    return j;

# Avaliação do desempenho de diferentes algoritmos para diferentes quantidades de números

# Variáveis globais necessárias:
medicoes = []                      # lista que armazena os resultados das medições em memória

# lista de algoritmos a testar (insira o seu, caso elabore outros):
algoritmos = { 
    'BSRT': { 'nome': 'Bubble sort', 'funcao': bubble_sort },
    'CSRT': { 'nome': 'Comb sort', 'funcao': comb_sort },
    'SSRT': { 'nome': 'Shake sort', 'funcao': shake_sort },
    'QSTR': { 'nome': 'Quick sort tradicional', 'funcao': quick_sort},
    'QSMD': { 'nome': 'Quick sort melhorado', 'funcao': quick_sort2},    
    # insira o seu aqui usando a sintaxe acima
}  

# testa o desempenho dos algoritmos para diferentes quantidades (múltiplos de 10):
for qtd in [10**x for x in range(2, 3)]:
    max = qtd
    array = list(range(qtd, 0, -1))                   # array decrescente (pior caso)
    
    print('---------------------------------------------------')
    print('Testando algoritmos com array de tamanho ', qtd)
    print('---------------------------------------------------')
    
    print('Array gerado (', qtd, 'numeros ):\n' , array, '\n') 
    
    for algoritmo in algoritmos:                       # itera sobre cada um dos algoritmos enunciados anteriormente
        print('=> Avaliando ordenação por "', algoritmos[algoritmo]['nome'], '"...')
        
        array_tmp = array.copy()                       # faz cópia do array para não perder
        
        tempo = time.process_time()                     # armazena o tempo de início do processamento
        m = algoritmos[algoritmo]['funcao'](array_tmp ) # aplica algorimo e retorna quantidade de trocas e comparações em 'm'
        t = time.process_time() - tempo                 # verifica o tempo de fim de processamento e calcula a diferença
        print('\nArray ordenado:\n', array_tmp, '\n')
        
        # armazena informações sobre a execução do algoritmo em um dicionário:
        medicao = {}
        medicao['algoritmo']=algoritmo
        medicao['tipo']='R'
        medicao['quantidade']=qtd
        medicao['trocas']=m['trocas']
        medicao['comparacoes']=m['comparacoes']
        medicao['tempo']=t
        
        medicoes.append(medicao)                              # adiciona medição em uma lista de medições

print('Fim do processamento!')

# Cria dataframe pandas (i.e., uma tabela) que organiza os dados relacionados com a execução dos algorimos acima
df = pd.DataFrame(medicoes)
cols = ['algoritmo', 'tipo', 'quantidade', 'trocas', 'comparacoes', 'tempo']  # ordem correta das colunas 
df = df[cols]

print(df) # imprime os dados de execução dos algoritmos

"""Exercícios:
==========

1. Elabore a função de ordenação correspondente aos algoritmos 'shake sort' e 'comb sort'. Reexecute e veja se muda alguma coisa.

2. Observe o código seguinte que aplica o quicksort em 10.000 elementos já ordenados. Verifique que ocore estouro de pilha, visto que seu pior caso gera muitas recursões na pilha -> O(nˆ2). Tente resolver esse problema. A solução envolve criar uma nova função de partição que utilize alguma abordagem diferente para a escolha do pivô. Tente não mudar o algoritmo, mas trocar o elemento que lá está por outro (aleatório, mediano entre primeiro, do meio e o último....). Há outras opções, como fazer uma mudança aleatória de posição de alguns elementos do array original. Finalmente, verifique se sua solução não cai no pior caso quanto todos os elementos são iguais...

3. Modifique o código de maneira a avaliar diferentes tipos de arrays (crescentes, decrescentes e aleatórios), em diferentes tamanhos (100, 1000, 10000 e 100000). Verifique se o algoritmo funciona para todos os casos e se ele realmente é melhor do que os vistos anteriormente (ao menos em outras situações que não sejam o pior caso). Explique os motivos, caso não funcione ou tenha desempenho pior que o insertionsort. Verifique ainda se o algoritmo funciona para arrays cujos elementos sejam todos iguais (10000 elementos) e, caso não funcione, explique os motivos. Procure resolver os problemas, fazendo com que o algoritmo não caia no pior caso e também com que ele não tenha problemas quando todos os elementos forem iguais.
"""

# Avaliação do desempenho de diferentes algoritmos para diferentes quantidades de números

# Variáveis globais necessárias:
medicoes = []                      # lista que armazena os resultados das medições em memória

# lista de algoritmos a testar (insira o seu, caso elabore outros):
algoritmos = { 
    'QSMD': { 'nome': 'Quick sort melhorado', 'funcao': quick_sort2},  
    # insira o seu aqui usando a sintaxe acima
}  

# testa o desempenho dos algoritmos para diferentes quantidades (múltiplos de 10):
for qtd in [10**x for x in range(2, 6)]:
    max = qtd
    array = list(range(0, qtd, 1)) 
    
    print('---------------------------------------------------')
    print('Testando algoritmos com array CRESCENTE de tamanho ', qtd)
    print('---------------------------------------------------')
    
    print('Array gerado (', qtd, 'numeros ):\n' , array, '\n') 
    
    for algoritmo in algoritmos:                       # itera sobre cada um dos algoritmos enunciados anteriormente
        print('=> Avaliando ordenação por "', algoritmos[algoritmo]['nome'], '"...')
        
        array_tmp = array.copy()                       # faz cópia do array para não perder
        
        tempo = time.process_time()                     # armazena o tempo de início do processamento
        m = algoritmos[algoritmo]['funcao'](array_tmp ) # aplica algorimo e retorna quantidade de trocas e comparações em 'm'
        t = time.process_time() - tempo                 # verifica o tempo de fim de processamento e calcula a diferença
        print('\nArray ordenado:\n', array_tmp, '\n')
        
        # armazena informações sobre a execução do algoritmo em um dicionário:
        medicao = {}
        medicao['algoritmo']=algoritmo
        medicao['tipo']='CRESCENTE'
        medicao['quantidade']=qtd
        medicao['trocas']=m['trocas']
        medicao['comparacoes']=m['comparacoes']
        medicao['tempo']=t
        
        medicoes.append(medicao)                              # adiciona medição em uma lista de medições

print('Fim do processamento!')

for qtd in [10**x for x in range(2, 6)]:
    max = qtd
    array = list(range(qtd, 0, -1))                   # array decrescente (pior caso)
   
    print('---------------------------------------------------')
    print('Testando algoritmos com array DECRESCENTE de tamanho ', qtd)
    print('---------------------------------------------------')
    
    print('Array gerado (', qtd, 'numeros ):\n' , array, '\n') 
    
    for algoritmo in algoritmos:                       # itera sobre cada um dos algoritmos enunciados anteriormente
        print('=> Avaliando ordenação por "', algoritmos[algoritmo]['nome'], '"...')
        
        array_tmp = array.copy()                       # faz cópia do array para não perder
        
        tempo = time.process_time()                     # armazena o tempo de início do processamento
        m = algoritmos[algoritmo]['funcao'](array_tmp ) # aplica algorimo e retorna quantidade de trocas e comparações em 'm'
        t = time.process_time() - tempo                 # verifica o tempo de fim de processamento e calcula a diferença
        print('\nArray ordenado:\n', array_tmp, '\n')
        
        # armazena informações sobre a execução do algoritmo em um dicionário:
        medicao = {}
        medicao['algoritmo']=algoritmo
        medicao['tipo']='DECRESCENTE'
        medicao['quantidade']=qtd
        medicao['trocas']=m['trocas']
        medicao['comparacoes']=m['comparacoes']
        medicao['tempo']=t
        
        medicoes.append(medicao)                              # adiciona medição em uma lista de medições

print('Fim do processamento!')

for qtd in [10**x for x in range(2, 6)]:
    max = qtd

    from random import shuffle
    array = list(range(0, qtd, 1))
    random.shuffle(array) 
    
    print('---------------------------------------------------')
    print('Testando algoritmos com array ALEATORIO de tamanho ', qtd)
    print('---------------------------------------------------')
    
    print('Array gerado (', qtd, 'numeros ):\n' , array, '\n') 
    
    for algoritmo in algoritmos:                       # itera sobre cada um dos algoritmos enunciados anteriormente
        print('=> Avaliando ordenação por "', algoritmos[algoritmo]['nome'], '"...')
        
        array_tmp = array.copy()                       # faz cópia do array para não perder
        
        tempo = time.process_time()                     # armazena o tempo de início do processamento
        m = algoritmos[algoritmo]['funcao'](array_tmp ) # aplica algorimo e retorna quantidade de trocas e comparações em 'm'
        t = time.process_time() - tempo                 # verifica o tempo de fim de processamento e calcula a diferença
        print('\nArray ordenado:\n', array_tmp, '\n')
        
        # armazena informações sobre a execução do algoritmo em um dicionário:
        medicao = {}
        medicao['algoritmo']=algoritmo
        medicao['tipo']='ALEATORIO'
        medicao['quantidade']=qtd
        medicao['trocas']=m['trocas']
        medicao['comparacoes']=m['comparacoes']
        medicao['tempo']=t
        
        medicoes.append(medicao)                              # adiciona medição em uma lista de medições

print('Fim do processamento!')

for qtd in [10**x for x in range(2, 6)]:
    max = qtd
    array = np.ones(qtd, dtype=int) 
    
    print('---------------------------------------------------')
    print('Testando algoritmos com array REPETIDO COM 1 de tamanho ', qtd)
    print('---------------------------------------------------')
    
    print('Array gerado (', qtd, 'numeros ):\n' , array, '\n') 
    
    for algoritmo in algoritmos:                       # itera sobre cada um dos algoritmos enunciados anteriormente
        print('=> Avaliando ordenação por "', algoritmos[algoritmo]['nome'], '"...')
        
        array_tmp = array.copy()                       # faz cópia do array para não perder
        
        tempo = time.process_time()                     # armazena o tempo de início do processamento
        m = algoritmos[algoritmo]['funcao'](array_tmp ) # aplica algorimo e retorna quantidade de trocas e comparações em 'm'
        t = time.process_time() - tempo                 # verifica o tempo de fim de processamento e calcula a diferença
        print('\nArray ordenado:\n', array_tmp, '\n')
        
        # armazena informações sobre a execução do algoritmo em um dicionário:
        medicao = {}
        medicao['algoritmo']=algoritmo
        medicao['tipo']='FIXO'
        medicao['quantidade']=qtd
        medicao['trocas']=m['trocas']
        medicao['comparacoes']=m['comparacoes']
        medicao['tempo']=t
        
        medicoes.append(medicao)                              # adiciona medição em uma lista de medições

print('Fim do processamento!')

# Cria dataframe pandas (i.e., uma tabela) que organiza os dados relacionados com a execução dos algorimos acima
df = pd.DataFrame(medicoes)
cols = ['algoritmo', 'tipo', 'quantidade', 'trocas', 'comparacoes', 'tempo']  # ordem correta das colunas 
df = df[cols]

print(df) # imprime os dados de execução dos algoritmos